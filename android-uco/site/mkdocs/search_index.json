{
    "docs": [
        {
            "location": "/", 
            "text": "Desarrollo de una app b\u00e1sica\n\n\nEl \nGDG de C\u00f3rdoba\n junto al \nAula de Software libre\n de la \nUCO\n promueven este taller para que los participantes aprendan a crear una aplicaci\u00f3n b\u00e1sica con Android, entender los entresijos y poder as\u00ed customizar la aplicaci\u00f3n a su gusto.\n\n\nQu\u00e9 debo de tener instalado\n\n\n\n\nAndroid Studio.\n\n\nAndroid Support Repository 47.0.0\n\n\nSDK 23 o 24 (Android 6.0 o 7.0).\n\n\nDispositivo virtual para testeo o bien un dispositivo f\u00edsico.", 
            "title": "Inicio"
        }, 
        {
            "location": "/#desarrollo-de-una-app-basica", 
            "text": "El  GDG de C\u00f3rdoba  junto al  Aula de Software libre  de la  UCO  promueven este taller para que los participantes aprendan a crear una aplicaci\u00f3n b\u00e1sica con Android, entender los entresijos y poder as\u00ed customizar la aplicaci\u00f3n a su gusto.", 
            "title": "Desarrollo de una app b\u00e1sica"
        }, 
        {
            "location": "/#que-debo-de-tener-instalado", 
            "text": "Android Studio.  Android Support Repository 47.0.0  SDK 23 o 24 (Android 6.0 o 7.0).  Dispositivo virtual para testeo o bien un dispositivo f\u00edsico.", 
            "title": "Qu\u00e9 debo de tener instalado"
        }, 
        {
            "location": "/create_project/", 
            "text": "Creaci\u00f3n de un proyecto\n\n\nAbrimos Android Studio y pulsamos en \nStart a new Android Studio project\n\n\n\n\nIntroducimos el nombre de nuestro proyecto, en nuestro caso \nUCOExample\n\n\n\n\nAhora tenemos que elegir el SDK m\u00ednimo con el que vamos a desarrollar la app. En nuestro caso vamos a usar \n19\n, que es soportada por el 90,1% de los dispositivos actualmente.\n\n\nC\u00f3mo vamos a hacer una app m\u00f3vil, s\u00f3lo tenemos que marcar la opci\u00f3n de \nPhone and Tablet\n.\n\n\n\n\nAndroid Studio nos proponer ahora una serie de actividades iniciales. Podemos elegir varias, c\u00f3mo por ejemplo una con un \nFAB\n (Floating Action Button), una con una barra de navegaci\u00f3n inferior, o incluso una actividad con mapa. Por experiencia, es m\u00e1s recomendable usar una actividad vac\u00eda y as\u00ed controlamos el c\u00f3digo que vamos generando.\n\n\nEn nuestro caso y c\u00f3mo vamos a hacer una aplicaci\u00f3n desde cero, elegimos \nEmpty Activity\n.\n\n\n\n\nPor \u00faltimo, ahora nos toca ponerle un nombre a la actividad, dejaremos el que viene por defecto ya que si en cualquier momento nos hace falta cambiarlo podemos hacerlo con la opci\u00f3n de \nRefactor\n que incluye el IDE.\n\n\nTenemos que tener en cuenta antes de finalizar, que queremos que AS nos genere el archivo de layout correspondiente a la actividad. Dependiendo del nombre que le demos coger\u00e1 el nombre y le a\u00f1adir\u00e1 activity.\n\n\n\n\nUna vez hayamos escrito el nombre que queramos que tenga nuestro layout, pulsamos en \nAceptar\n y AS empezar\u00e1 a generar nuestro proyecto.\n\n\nUna vez que AS termine de indexar todo el proyecto, ya podemos comenzar.\n\n\nLanzar la aplicaci\u00f3n\n\n\nPara lanzar la aplicaci\u00f3n, lo primero que debemos hacer es comprobar esta parte de Android Studio.\n\n\n \n\n\nEn orden, los tres botones coloreados son:\n\n\n\n\nLanzar la aplicaci\u00f3n en el emulador.\n\n\nLanzar la aplicaci\u00f3n en modo debug.\n\n\nAVD Manager.\n\n\n\n\nConfigurar el emulador\n\n\nSi no tenemos un emulador configurado, pulsamos primero en el bot\u00f3n de \nAVD Manager\n.\n\n\nNos aparecer\u00e1 una ventana con el listado de emuladores instalados en nuestro sistema.\n\n\n\n\nPara crear uno, pulsamos el bot\u00f3n de \nCreate Virtual Device\n situado abajo a la izquierda.\n\n\nAhora nos saldr\u00e1 una ventana con un listado de m\u00f3viles y tablets que podemos elegir para emular. En nuestro caso vamos a crear un emulador para un \nGoogle Pixel XL\n.\n\n\n\n\nPulsamos en \nNext\n y ahora hay que elegir el sistema operativo del m\u00f3vil. En nuestro caso vamos a elegir Marshmallow (Android 6.0). Por \u00faltimo elegimos el nombre de nuestro emulador y AS nos informa de los datos del mismo.\n\n\nUna vez creado el emulador, s\u00f3lo tenemos que pulsar en el bot\u00f3n de lanzar la app, elegir el m\u00f3vil al que queremos lanzar la aplicaci\u00f3n y esperar a que arranque.", 
            "title": "Crear proyecto"
        }, 
        {
            "location": "/create_project/#creacion-de-un-proyecto", 
            "text": "Abrimos Android Studio y pulsamos en  Start a new Android Studio project   Introducimos el nombre de nuestro proyecto, en nuestro caso  UCOExample   Ahora tenemos que elegir el SDK m\u00ednimo con el que vamos a desarrollar la app. En nuestro caso vamos a usar  19 , que es soportada por el 90,1% de los dispositivos actualmente.  C\u00f3mo vamos a hacer una app m\u00f3vil, s\u00f3lo tenemos que marcar la opci\u00f3n de  Phone and Tablet .   Android Studio nos proponer ahora una serie de actividades iniciales. Podemos elegir varias, c\u00f3mo por ejemplo una con un  FAB  (Floating Action Button), una con una barra de navegaci\u00f3n inferior, o incluso una actividad con mapa. Por experiencia, es m\u00e1s recomendable usar una actividad vac\u00eda y as\u00ed controlamos el c\u00f3digo que vamos generando.  En nuestro caso y c\u00f3mo vamos a hacer una aplicaci\u00f3n desde cero, elegimos  Empty Activity .   Por \u00faltimo, ahora nos toca ponerle un nombre a la actividad, dejaremos el que viene por defecto ya que si en cualquier momento nos hace falta cambiarlo podemos hacerlo con la opci\u00f3n de  Refactor  que incluye el IDE.  Tenemos que tener en cuenta antes de finalizar, que queremos que AS nos genere el archivo de layout correspondiente a la actividad. Dependiendo del nombre que le demos coger\u00e1 el nombre y le a\u00f1adir\u00e1 activity.   Una vez hayamos escrito el nombre que queramos que tenga nuestro layout, pulsamos en  Aceptar  y AS empezar\u00e1 a generar nuestro proyecto.  Una vez que AS termine de indexar todo el proyecto, ya podemos comenzar.", 
            "title": "Creaci\u00f3n de un proyecto"
        }, 
        {
            "location": "/create_project/#lanzar-la-aplicacion", 
            "text": "Para lanzar la aplicaci\u00f3n, lo primero que debemos hacer es comprobar esta parte de Android Studio.     En orden, los tres botones coloreados son:   Lanzar la aplicaci\u00f3n en el emulador.  Lanzar la aplicaci\u00f3n en modo debug.  AVD Manager.", 
            "title": "Lanzar la aplicaci\u00f3n"
        }, 
        {
            "location": "/create_project/#configurar-el-emulador", 
            "text": "Si no tenemos un emulador configurado, pulsamos primero en el bot\u00f3n de  AVD Manager .  Nos aparecer\u00e1 una ventana con el listado de emuladores instalados en nuestro sistema.   Para crear uno, pulsamos el bot\u00f3n de  Create Virtual Device  situado abajo a la izquierda.  Ahora nos saldr\u00e1 una ventana con un listado de m\u00f3viles y tablets que podemos elegir para emular. En nuestro caso vamos a crear un emulador para un  Google Pixel XL .   Pulsamos en  Next  y ahora hay que elegir el sistema operativo del m\u00f3vil. En nuestro caso vamos a elegir Marshmallow (Android 6.0). Por \u00faltimo elegimos el nombre de nuestro emulador y AS nos informa de los datos del mismo.  Una vez creado el emulador, s\u00f3lo tenemos que pulsar en el bot\u00f3n de lanzar la app, elegir el m\u00f3vil al que queremos lanzar la aplicaci\u00f3n y esperar a que arranque.", 
            "title": "Configurar el emulador"
        }, 
        {
            "location": "/vista/", 
            "text": "Organizar la vista\n\n\nAntes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.\n\n\nPara crear una vista, debemos editar el archivo \nactivity_main.xml\n que nos cre\u00f3 \nAndroid Studio\n cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase \nJava\n, infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.\n\n\nHay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de \nUI\n (\nUser Interface\n).\n\n\nPodemos tener un dise\u00f1o linar (\nLinearLayout\n) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con \nGridLayout\n o \nTableLayout\n. Hay layouts especiales para mostrar un fragment (\nFrameLayout\n). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con \nRelativeLayout\n.", 
            "title": "Organizar la vista"
        }, 
        {
            "location": "/vista/#organizar-la-vista", 
            "text": "Antes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.  Para crear una vista, debemos editar el archivo  activity_main.xml  que nos cre\u00f3  Android Studio  cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase  Java , infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.  Hay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de  UI  ( User Interface ).  Podemos tener un dise\u00f1o linar ( LinearLayout ) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con  GridLayout  o  TableLayout . Hay layouts especiales para mostrar un fragment ( FrameLayout ). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con  RelativeLayout .", 
            "title": "Organizar la vista"
        }, 
        {
            "location": "/api/", 
            "text": "Usando una API externa\n\n\nUna API es una Interfaz de Programaci\u00f3n de Aplicaciones (Application Programming Interface). B\u00e1sicamente, una API es un servidor que gracias a unos m\u00e9todos en su c\u00f3digo, nos va a proveer de datos para nuestro uso.\n\n\nEn nuestro caso, y debido a su simplicidad, vamos a hacer una aplicaci\u00f3n que pida datos a una API sobre perros, con la que montaremos un listado y un perfil para el perro.\n\n\nNuestra API es \ndogapi\n.\n\n\nConexi\u00f3n con la API\n\n\nPara empezar, debemos a\u00f1adir las dependencias de \nRetrofit\n, que es la librer\u00eda que vamos a usar para la conexi\u00f3n con nuestra API. Retrofit es un cliente HTTP hecho para Java y Android.\n\n\nbuild.gradle (Module: app)\n\n\n  compile \ncom.squareup.retrofit2:retrofit:2.3.0\n\n  compile \ncom.squareup.retrofit2:converter-gson:2.3.0\n\n\n\n\n\nCuando introducimos c\u00f3digo en Gradle, tenemos que volver a sincronizar el c\u00f3digo para que los cambios sean efectivos.\n\n\nAhora creamos un nuevo Package llamado API.\n\n\n\n\nAntes de Retrofit\n\n\nTenemos que crear nuestro modelo de datos, que nos servir\u00e1 para recoger la informaci\u00f3n del servidor.\n\n\nCreamos un Package llamado entities y dentro de \u00e9l un archivo BreedWrapper.java\n\n\npublic class BreedWrapper {\n    @SerializedName(\nmessage\n)\n    private List\nString\n breeds;\n}\n\n\n\n\nConfigurando Retrofit\n\n\nCuando trabajamos con Retrofit, debemos tener dos archivos b\u00e1sicos. Uno de ellos es una interfaz donde definiremos todos los m\u00e9todos que usaremos para conectarnos a la API (por ejemplo traer todas las razas de perros o informaci\u00f3n acerca de una).\n\n\nEl otro es el cliente, que nos servir\u00e1 para configurar nuestra conexi\u00f3n con la API y todo lo que le queramos a\u00f1adir a Retrofit (por ejemplo un Interceptor). Aqu\u00ed tambi\u00e9n instanciamos la interfaz para que podamos usar los m\u00e9todos en nuestro c\u00f3digo.\n\n\nCreamos nuestra interfaz. La vamos a llamar \nDogService.java\n.\n\n\npublic interface DogService {\n    @GET(\nbreeds/list\n)\n    Call\nBreedWrapper\n getBreeds();\n}\n\n\n\n\nAhora vamos a crear el cliente, \nDogClient.java\n\n\npublic class DogClient {\n    private Retrofit retrofit;\n    private final static String BASE_URL = \nhttps://dog.ceo/api/\n;\n\n    public DogClient(){\n        this.retrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n    }\n\n    public DogService getDogService(){\n        return this.retrofit.create(DogService.class);\n    }\n}\n\n\n\n\nCon DogService.java estamos creando un \"puente\" entre nuestra app y la API. Cuando queramos traer todas las razas de perro, solamente tendremos que instanciar esa interfaz y usar el m\u00e9todo.\n\n\nEl cliente, nos sirve para hacer la conexi\u00f3n. Tenemos la url b\u00e1sica de la api \nhttps://dog.ceo/api/", 
            "title": "Usando una API externa"
        }, 
        {
            "location": "/api/#usando-una-api-externa", 
            "text": "Una API es una Interfaz de Programaci\u00f3n de Aplicaciones (Application Programming Interface). B\u00e1sicamente, una API es un servidor que gracias a unos m\u00e9todos en su c\u00f3digo, nos va a proveer de datos para nuestro uso.  En nuestro caso, y debido a su simplicidad, vamos a hacer una aplicaci\u00f3n que pida datos a una API sobre perros, con la que montaremos un listado y un perfil para el perro.  Nuestra API es  dogapi .", 
            "title": "Usando una API externa"
        }, 
        {
            "location": "/api/#conexion-con-la-api", 
            "text": "Para empezar, debemos a\u00f1adir las dependencias de  Retrofit , que es la librer\u00eda que vamos a usar para la conexi\u00f3n con nuestra API. Retrofit es un cliente HTTP hecho para Java y Android.  build.gradle (Module: app)    compile  com.squareup.retrofit2:retrofit:2.3.0 \n  compile  com.squareup.retrofit2:converter-gson:2.3.0   Cuando introducimos c\u00f3digo en Gradle, tenemos que volver a sincronizar el c\u00f3digo para que los cambios sean efectivos.  Ahora creamos un nuevo Package llamado API.", 
            "title": "Conexi\u00f3n con la API"
        }, 
        {
            "location": "/api/#antes-de-retrofit", 
            "text": "Tenemos que crear nuestro modelo de datos, que nos servir\u00e1 para recoger la informaci\u00f3n del servidor.  Creamos un Package llamado entities y dentro de \u00e9l un archivo BreedWrapper.java  public class BreedWrapper {\n    @SerializedName( message )\n    private List String  breeds;\n}", 
            "title": "Antes de Retrofit"
        }, 
        {
            "location": "/api/#configurando-retrofit", 
            "text": "Cuando trabajamos con Retrofit, debemos tener dos archivos b\u00e1sicos. Uno de ellos es una interfaz donde definiremos todos los m\u00e9todos que usaremos para conectarnos a la API (por ejemplo traer todas las razas de perros o informaci\u00f3n acerca de una).  El otro es el cliente, que nos servir\u00e1 para configurar nuestra conexi\u00f3n con la API y todo lo que le queramos a\u00f1adir a Retrofit (por ejemplo un Interceptor). Aqu\u00ed tambi\u00e9n instanciamos la interfaz para que podamos usar los m\u00e9todos en nuestro c\u00f3digo.  Creamos nuestra interfaz. La vamos a llamar  DogService.java .  public interface DogService {\n    @GET( breeds/list )\n    Call BreedWrapper  getBreeds();\n}  Ahora vamos a crear el cliente,  DogClient.java  public class DogClient {\n    private Retrofit retrofit;\n    private final static String BASE_URL =  https://dog.ceo/api/ ;\n\n    public DogClient(){\n        this.retrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n    }\n\n    public DogService getDogService(){\n        return this.retrofit.create(DogService.class);\n    }\n}  Con DogService.java estamos creando un \"puente\" entre nuestra app y la API. Cuando queramos traer todas las razas de perro, solamente tendremos que instanciar esa interfaz y usar el m\u00e9todo.  El cliente, nos sirve para hacer la conexi\u00f3n. Tenemos la url b\u00e1sica de la api  https://dog.ceo/api/", 
            "title": "Configurando Retrofit"
        }, 
        {
            "location": "/listado/", 
            "text": "Crear un listado de elementos\n\n\nPara crear una lista de elementos, tenemos varias opciones. Podemos usar \nListView\n, \nRecyclerView\n, o \nGridView\n.\n\n\nNuestra implementaci\u00f3n va a ser un listado vertical con datos. Un ejemplo de lo que queremos montar ser\u00eda:\n\n\n\n\nDiferencia entre ListView y RecyclerView\n\n\nTanto el ListView como el RecyclerView nos sirven en caso de querer hacer listado como el de la imagen. Las diferencias son que el RecyclerView es una implementaci\u00f3n m\u00e1s nueva, da m\u00e1s flexibilidad con animaciones, y adem\u00e1s, como en su nombre se indica, recicla los items de la tabla por lo que supone un ahorro en memoria. El RecyclerView s\u00f3lo tiene declarados los items visibles, y uno por encima y por debajo. Cuando el usuario hace scroll, las celdas que ya no se ven se reutilizan para mostrar las nuevas.\n\n\nEn esta gu\u00eda vamos a usar RecyclerView por estas razones.", 
            "title": "Crear un listado"
        }, 
        {
            "location": "/listado/#crear-un-listado-de-elementos", 
            "text": "Para crear una lista de elementos, tenemos varias opciones. Podemos usar  ListView ,  RecyclerView , o  GridView .  Nuestra implementaci\u00f3n va a ser un listado vertical con datos. Un ejemplo de lo que queremos montar ser\u00eda:", 
            "title": "Crear un listado de elementos"
        }, 
        {
            "location": "/listado/#diferencia-entre-listview-y-recyclerview", 
            "text": "Tanto el ListView como el RecyclerView nos sirven en caso de querer hacer listado como el de la imagen. Las diferencias son que el RecyclerView es una implementaci\u00f3n m\u00e1s nueva, da m\u00e1s flexibilidad con animaciones, y adem\u00e1s, como en su nombre se indica, recicla los items de la tabla por lo que supone un ahorro en memoria. El RecyclerView s\u00f3lo tiene declarados los items visibles, y uno por encima y por debajo. Cuando el usuario hace scroll, las celdas que ya no se ven se reutilizan para mostrar las nuevas.  En esta gu\u00eda vamos a usar RecyclerView por estas razones.", 
            "title": "Diferencia entre ListView y RecyclerView"
        }
    ]
}