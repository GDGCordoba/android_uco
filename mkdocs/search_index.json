{
    "docs": [
        {
            "location": "/", 
            "text": "Desarrollo de una app b\u00e1sica\n\n\nEl \nGDG de C\u00f3rdoba\n junto al \nAula de Software libre\n de la \nUCO\n promueven este taller para que los participantes aprendan a crear una aplicaci\u00f3n b\u00e1sica con Android, entender los entresijos y poder as\u00ed customizar la aplicaci\u00f3n a su gusto.\n\n\nQu\u00e9 debo de tener instalado\n\n\n\n\nAndroid Studio.\n\n\nAndroid Support Repository 47.0.0\n\n\nSDK 23 o 24 (Android 6.0 o 7.0).\n\n\nDispositivo virtual para testeo o bien un dispositivo f\u00edsico.", 
            "title": "Inicio"
        }, 
        {
            "location": "/#desarrollo-de-una-app-basica", 
            "text": "El  GDG de C\u00f3rdoba  junto al  Aula de Software libre  de la  UCO  promueven este taller para que los participantes aprendan a crear una aplicaci\u00f3n b\u00e1sica con Android, entender los entresijos y poder as\u00ed customizar la aplicaci\u00f3n a su gusto.", 
            "title": "Desarrollo de una app b\u00e1sica"
        }, 
        {
            "location": "/#que-debo-de-tener-instalado", 
            "text": "Android Studio.  Android Support Repository 47.0.0  SDK 23 o 24 (Android 6.0 o 7.0).  Dispositivo virtual para testeo o bien un dispositivo f\u00edsico.", 
            "title": "Qu\u00e9 debo de tener instalado"
        }, 
        {
            "location": "/create_project/", 
            "text": "Creaci\u00f3n de un proyecto\n\n\nCreando un nuevo proyecto\n\n\nAbrimos Android Studio y pulsamos en \nStart a new Android Studio project\n\n\n\n\nIntroducimos el nombre de nuestro proyecto, en nuestro caso \nUCOExample\n\n\n\n\nAhora tenemos que elegir el SDK m\u00ednimo con el que vamos a desarrollar la app. En nuestro caso vamos a usar \n19\n, que es soportada por el 90,1% de los dispositivos actualmente.\n\n\nC\u00f3mo vamos a hacer una app m\u00f3vil, s\u00f3lo tenemos que marcar la opci\u00f3n de \nPhone and Tablet\n.\n\n\n\n\nAndroid Studio nos proponer ahora una serie de actividades iniciales. Podemos elegir varias, c\u00f3mo por ejemplo una con un \nFAB\n (Floating Action Button), una con una barra de navegaci\u00f3n inferior, o incluso una actividad con mapa. Por experiencia, es m\u00e1s recomendable usar una actividad vac\u00eda y as\u00ed controlamos el c\u00f3digo que vamos generando.\n\n\nEn nuestro caso y c\u00f3mo vamos a hacer una aplicaci\u00f3n desde cero, elegimos \nEmpty Activity\n.\n\n\n\n\nPor \u00faltimo, ahora nos toca ponerle un nombre a la actividad, dejaremos el que viene por defecto ya que si en cualquier momento nos hace falta cambiarlo podemos hacerlo con la opci\u00f3n de \nRefactor\n que incluye el IDE.\n\n\nTenemos que tener en cuenta antes de finalizar, que queremos que AS nos genere el archivo de layout correspondiente a la actividad. Dependiendo del nombre que le demos coger\u00e1 el nombre y le a\u00f1adir\u00e1 activity.\n\n\n\n\nUna vez hayamos escrito el nombre que queramos que tenga nuestro layout, pulsamos en \nAceptar\n y AS empezar\u00e1 a generar nuestro proyecto.\n\n\nUna vez que AS termine de indexar todo el proyecto, ya podemos comenzar.\n\n\nLanzar la aplicaci\u00f3n\n\n\nPara lanzar la aplicaci\u00f3n, lo primero que debemos hacer es comprobar esta parte de Android Studio.\n\n\n \n\n\nEn orden, los tres botones coloreados son:\n\n\n\n\nLanzar la aplicaci\u00f3n en el emulador.\n\n\nLanzar la aplicaci\u00f3n en modo debug.\n\n\nAVD Manager.\n\n\n\n\nConfigurar el emulador\n\n\nSi no tenemos un emulador configurado, pulsamos primero en el bot\u00f3n de \nAVD Manager\n.\n\n\nNos aparecer\u00e1 una ventana con el listado de emuladores instalados en nuestro sistema.\n\n\n\n\nPara crear uno, pulsamos el bot\u00f3n de \nCreate Virtual Device\n situado abajo a la izquierda.\n\n\nAhora nos saldr\u00e1 una ventana con un listado de m\u00f3viles y tablets que podemos elegir para emular. En nuestro caso vamos a crear un emulador para un \nGoogle Pixel XL\n.\n\n\n\n\nPulsamos en \nNext\n y ahora hay que elegir el sistema operativo del m\u00f3vil. En nuestro caso vamos a elegir Marshmallow (Android 6.0). Por \u00faltimo elegimos el nombre de nuestro emulador y AS nos informa de los datos del mismo.\n\n\nUna vez creado el emulador, s\u00f3lo tenemos que pulsar en el bot\u00f3n de lanzar la app, elegir el m\u00f3vil al que queremos lanzar la aplicaci\u00f3n y esperar a que arranque.", 
            "title": "Crear proyecto"
        }, 
        {
            "location": "/create_project/#creacion-de-un-proyecto", 
            "text": "", 
            "title": "Creaci\u00f3n de un proyecto"
        }, 
        {
            "location": "/create_project/#creando-un-nuevo-proyecto", 
            "text": "Abrimos Android Studio y pulsamos en  Start a new Android Studio project   Introducimos el nombre de nuestro proyecto, en nuestro caso  UCOExample   Ahora tenemos que elegir el SDK m\u00ednimo con el que vamos a desarrollar la app. En nuestro caso vamos a usar  19 , que es soportada por el 90,1% de los dispositivos actualmente.  C\u00f3mo vamos a hacer una app m\u00f3vil, s\u00f3lo tenemos que marcar la opci\u00f3n de  Phone and Tablet .   Android Studio nos proponer ahora una serie de actividades iniciales. Podemos elegir varias, c\u00f3mo por ejemplo una con un  FAB  (Floating Action Button), una con una barra de navegaci\u00f3n inferior, o incluso una actividad con mapa. Por experiencia, es m\u00e1s recomendable usar una actividad vac\u00eda y as\u00ed controlamos el c\u00f3digo que vamos generando.  En nuestro caso y c\u00f3mo vamos a hacer una aplicaci\u00f3n desde cero, elegimos  Empty Activity .   Por \u00faltimo, ahora nos toca ponerle un nombre a la actividad, dejaremos el que viene por defecto ya que si en cualquier momento nos hace falta cambiarlo podemos hacerlo con la opci\u00f3n de  Refactor  que incluye el IDE.  Tenemos que tener en cuenta antes de finalizar, que queremos que AS nos genere el archivo de layout correspondiente a la actividad. Dependiendo del nombre que le demos coger\u00e1 el nombre y le a\u00f1adir\u00e1 activity.   Una vez hayamos escrito el nombre que queramos que tenga nuestro layout, pulsamos en  Aceptar  y AS empezar\u00e1 a generar nuestro proyecto.  Una vez que AS termine de indexar todo el proyecto, ya podemos comenzar.", 
            "title": "Creando un nuevo proyecto"
        }, 
        {
            "location": "/create_project/#lanzar-la-aplicacion", 
            "text": "Para lanzar la aplicaci\u00f3n, lo primero que debemos hacer es comprobar esta parte de Android Studio.     En orden, los tres botones coloreados son:   Lanzar la aplicaci\u00f3n en el emulador.  Lanzar la aplicaci\u00f3n en modo debug.  AVD Manager.", 
            "title": "Lanzar la aplicaci\u00f3n"
        }, 
        {
            "location": "/create_project/#configurar-el-emulador", 
            "text": "Si no tenemos un emulador configurado, pulsamos primero en el bot\u00f3n de  AVD Manager .  Nos aparecer\u00e1 una ventana con el listado de emuladores instalados en nuestro sistema.   Para crear uno, pulsamos el bot\u00f3n de  Create Virtual Device  situado abajo a la izquierda.  Ahora nos saldr\u00e1 una ventana con un listado de m\u00f3viles y tablets que podemos elegir para emular. En nuestro caso vamos a crear un emulador para un  Google Pixel XL .   Pulsamos en  Next  y ahora hay que elegir el sistema operativo del m\u00f3vil. En nuestro caso vamos a elegir Marshmallow (Android 6.0). Por \u00faltimo elegimos el nombre de nuestro emulador y AS nos informa de los datos del mismo.  Una vez creado el emulador, s\u00f3lo tenemos que pulsar en el bot\u00f3n de lanzar la app, elegir el m\u00f3vil al que queremos lanzar la aplicaci\u00f3n y esperar a que arranque.", 
            "title": "Configurar el emulador"
        }, 
        {
            "location": "/vista/", 
            "text": "Organizar la vista\n\n\nComo organizar nuestra vista\n\n\nAntes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.\n\n\nPara crear una vista, debemos editar el archivo \nactivity_main.xml\n que nos cre\u00f3 \nAndroid Studio\n cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase \nJava\n, infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.\n\n\nHay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de \nUI\n (\nUser Interface\n).\n\n\nPodemos tener un dise\u00f1o linar (\nLinearLayout\n) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con \nGridLayout\n o \nTableLayout\n. Hay layouts especiales para mostrar un fragment (\nFrameLayout\n). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con \nRelativeLayout\n.\n\n\n\n\nListado de razas de perro\n\n\nUna vez abramos nuestro activity_main.xml veremos que tenemos un ConstraintLayout y dentro de \u00e9l un TextView con un texto de ejemplo.\n\n\nComo no vamos a usar nada de constraints, cambiamos este por un LinearLayout, borramos el TextView y a\u00f1adimos un RecyclerView.\n\n\nSi miramos en la preview, nos dar\u00e1 un aviso de que nos falta la dependencia de RecyclerView, as\u00ed que vamos al build.gradle de app y a\u00f1adimos la siguiente l\u00ednea:\n\n\ncompile \ncom.android.support:recyclerview-v7:25.3.1\n\n\n\n\n\n\n\nNota\n\n\nCuando a\u00f1adimos una librer\u00eda a Gradle, la dependencia viene dividida en 3 partes divididas por \n:\n. La estructura de una dependencia es \nnombre-librer\u00eda:item-librer\u00eda:version\n. Cuando trabajemos con una misma librer\u00eda e importemos cosas distintas, tenemos que tener cuidado de que hay que importar la misma versi\u00f3n para todas.\n\n\n\n\nEl c\u00f3digo de nuestra vista puede ser as\u00ed:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nLinearLayout xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    xmlns:app=\nhttp://schemas.android.com/apk/res-auto\n\n    xmlns:tools=\nhttp://schemas.android.com/tools\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\nmatch_parent\n\n    tools:context=\ncom.example.david.ucoexample.MainActivity\n\n\n  \nandroid.support.v7.widget.RecyclerView\n       android:id=\n@+id/dogList\n\n       android:layout_width=\nmatch_parent\n\n       android:layout_height=\nmatch_parent\n\n\n  \n/android.support.v7.widget.RecyclerView\n\n\n\n/LinearLayout\n\n\n\n\n\nCrear item de perro\n\n\nUna vez que tenemos configurado el contenedor del listado, ahora tenemos que crear los items que vamos a mostrar. Como quedan muy curiosos, vamos a hacer CardViews, que son tarjetas implementadas por Android con la librer\u00eda de \nMaterial Design\n.\n\n\nPara crear un nuevo layout, hacemos click derecho sobre \nres/layout\n y vamos a \nNew/Layout resource file\n.\nComo nombre le pondremos \nitem_dog\n. En cuant a nomemclatura, en Android se suele poner primero si es item o alg\u00fan tipo de vista (activity, fragment) seguido de una barra baja y un nombre identificativo.\n\n\n\n\n\n\nUna vez tengramos creado nuestro layout, es hora de implementar nuestra primera CardView. Una card de Material es una hora que sirve como punto de entrada a informaci\u00f3n. En nuestro caso lo vamos a usar para listar razas de perro, que aunque es un listado sencillo y s\u00f3lo tendremos el nombre de la raza, vamos a intentar que destaque de alguna manera.\n\n\nAntes de nada, hay que ir a a\u00f1adir su dependencia:\n\n\ncompile \ncom.android.support:cardview-v7:25.3.1\n\n\n\n\n\nUna vez a\u00f1adida, la estructura b\u00e1sica de nuestro layout ser\u00eda:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nandroid.support.v7.widget.CardView\n    xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:layout_margin=\n8dp\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\n100dp\n\n\n    \nLinearLayout\n        android:orientation=\nhorizontal\n\n        android:layout_width=\nmatch_parent\n\n        android:layout_height=\nmatch_parent\n\n\n        \nImageView\n            android:src=\n@drawable/dog\n\n            android:layout_width=\n100dp\n\n            android:layout_height=\nmatch_parent\n /\n\n\n        \nTextView\n            android:id=\n@+id/dogBreedName\n\n            android:layout_width=\nwrap_content\n\n            android:layout_height=\nwrap_content\n /\n\n\n    \n/LinearLayout\n\n\n/android.support.v7.widget.CardView\n\n\n\n\n\nComo puedes ver, hemos puesto una CardView que a fin de cuentas es un contenedor del contenido interior. Dentro tenemos un LinearLayout horizontal, que tendr\u00e1 dos items, una imagen y un texto.\n\n\nPara la imagen vamos a usar una est\u00e1tica\n\n\n\n\nDebemos a\u00f1adir la imagen en \nres/drawable\n y le ponemos el nombre \ndog.png\n.", 
            "title": "Organizar la vista"
        }, 
        {
            "location": "/vista/#organizar-la-vista", 
            "text": "", 
            "title": "Organizar la vista"
        }, 
        {
            "location": "/vista/#como-organizar-nuestra-vista", 
            "text": "Antes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.  Para crear una vista, debemos editar el archivo  activity_main.xml  que nos cre\u00f3  Android Studio  cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase  Java , infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.  Hay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de  UI  ( User Interface ).  Podemos tener un dise\u00f1o linar ( LinearLayout ) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con  GridLayout  o  TableLayout . Hay layouts especiales para mostrar un fragment ( FrameLayout ). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con  RelativeLayout .", 
            "title": "Como organizar nuestra vista"
        }, 
        {
            "location": "/vista/#listado-de-razas-de-perro", 
            "text": "Una vez abramos nuestro activity_main.xml veremos que tenemos un ConstraintLayout y dentro de \u00e9l un TextView con un texto de ejemplo.  Como no vamos a usar nada de constraints, cambiamos este por un LinearLayout, borramos el TextView y a\u00f1adimos un RecyclerView.  Si miramos en la preview, nos dar\u00e1 un aviso de que nos falta la dependencia de RecyclerView, as\u00ed que vamos al build.gradle de app y a\u00f1adimos la siguiente l\u00ednea:  compile  com.android.support:recyclerview-v7:25.3.1", 
            "title": "Listado de razas de perro"
        }, 
        {
            "location": "/vista/#nota", 
            "text": "Cuando a\u00f1adimos una librer\u00eda a Gradle, la dependencia viene dividida en 3 partes divididas por  : . La estructura de una dependencia es  nombre-librer\u00eda:item-librer\u00eda:version . Cuando trabajemos con una misma librer\u00eda e importemos cosas distintas, tenemos que tener cuidado de que hay que importar la misma versi\u00f3n para todas.   El c\u00f3digo de nuestra vista puede ser as\u00ed:  ?xml version= 1.0  encoding= utf-8 ?  LinearLayout xmlns:android= http://schemas.android.com/apk/res/android \n    xmlns:app= http://schemas.android.com/apk/res-auto \n    xmlns:tools= http://schemas.android.com/tools \n    android:layout_width= match_parent \n    android:layout_height= match_parent \n    tools:context= com.example.david.ucoexample.MainActivity \n\n   android.support.v7.widget.RecyclerView\n       android:id= @+id/dogList \n       android:layout_width= match_parent \n       android:layout_height= match_parent \n\n   /android.support.v7.widget.RecyclerView  /LinearLayout", 
            "title": "Nota"
        }, 
        {
            "location": "/vista/#crear-item-de-perro", 
            "text": "Una vez que tenemos configurado el contenedor del listado, ahora tenemos que crear los items que vamos a mostrar. Como quedan muy curiosos, vamos a hacer CardViews, que son tarjetas implementadas por Android con la librer\u00eda de  Material Design .  Para crear un nuevo layout, hacemos click derecho sobre  res/layout  y vamos a  New/Layout resource file .\nComo nombre le pondremos  item_dog . En cuant a nomemclatura, en Android se suele poner primero si es item o alg\u00fan tipo de vista (activity, fragment) seguido de una barra baja y un nombre identificativo.    Una vez tengramos creado nuestro layout, es hora de implementar nuestra primera CardView. Una card de Material es una hora que sirve como punto de entrada a informaci\u00f3n. En nuestro caso lo vamos a usar para listar razas de perro, que aunque es un listado sencillo y s\u00f3lo tendremos el nombre de la raza, vamos a intentar que destaque de alguna manera.  Antes de nada, hay que ir a a\u00f1adir su dependencia:  compile  com.android.support:cardview-v7:25.3.1   Una vez a\u00f1adida, la estructura b\u00e1sica de nuestro layout ser\u00eda:  ?xml version= 1.0  encoding= utf-8 ?  android.support.v7.widget.CardView\n    xmlns:android= http://schemas.android.com/apk/res/android \n    android:layout_margin= 8dp \n    android:layout_width= match_parent \n    android:layout_height= 100dp \n\n     LinearLayout\n        android:orientation= horizontal \n        android:layout_width= match_parent \n        android:layout_height= match_parent \n\n         ImageView\n            android:src= @drawable/dog \n            android:layout_width= 100dp \n            android:layout_height= match_parent  / \n\n         TextView\n            android:id= @+id/dogBreedName \n            android:layout_width= wrap_content \n            android:layout_height= wrap_content  / \n\n     /LinearLayout  /android.support.v7.widget.CardView   Como puedes ver, hemos puesto una CardView que a fin de cuentas es un contenedor del contenido interior. Dentro tenemos un LinearLayout horizontal, que tendr\u00e1 dos items, una imagen y un texto.  Para la imagen vamos a usar una est\u00e1tica   Debemos a\u00f1adir la imagen en  res/drawable  y le ponemos el nombre  dog.png .", 
            "title": "Crear item de perro"
        }, 
        {
            "location": "/api/", 
            "text": "Usando una API externa\n\n\nQu\u00e9 es una API\n\n\nUna API es una Interfaz de Programaci\u00f3n de Aplicaciones (Application Programming Interface). B\u00e1sicamente, una API es un servidor que gracias a unos m\u00e9todos en su c\u00f3digo, nos va a proveer de datos para nuestro uso.\n\n\nEn nuestro caso, y debido a su simplicidad, vamos a hacer una aplicaci\u00f3n que pida datos a una API sobre perros, con la que montaremos un listado y un perfil para el perro.\n\n\nNuestra API es \ndogapi\n.\n\n\nConexi\u00f3n con la API\n\n\nPara empezar, debemos a\u00f1adir las dependencias de \nRetrofit\n, que es la librer\u00eda que vamos a usar para la conexi\u00f3n con nuestra API. Retrofit es un cliente HTTP hecho para Java y Android.\n\n\nbuild.gradle (Module: app)\n\n\n  compile \ncom.squareup.retrofit2:retrofit:2.3.0\n\n  compile \ncom.squareup.retrofit2:converter-gson:2.3.0\n\n\n\n\n\nCuando introducimos c\u00f3digo en Gradle, tenemos que volver a sincronizar el c\u00f3digo para que los cambios sean efectivos.\n\n\nAhora creamos un nuevo Package llamado API.\n\n\n\n\nAntes de Retrofit\n\n\nTenemos que crear nuestro modelo de datos, que nos servir\u00e1 para recoger la informaci\u00f3n del servidor.\n\n\nCreamos un Package llamado entities y dentro de \u00e9l un archivo BreedWrapper.java\n\n\npublic class BreedWrapper {\n    @SerializedName(\nmessage\n)\n    private List\nString\n breeds;\n\n    public List\nString\n getBreeds() {\n        return breeds;\n    }\n}\n\n\n\n\nConfigurando Retrofit\n\n\nCuando trabajamos con Retrofit, debemos tener dos archivos b\u00e1sicos. Uno de ellos es una interfaz donde definiremos todos los m\u00e9todos que usaremos para conectarnos a la API (por ejemplo traer todas las razas de perros o informaci\u00f3n acerca de una).\n\n\nEl otro es el cliente, que nos servir\u00e1 para configurar nuestra conexi\u00f3n con la API y todo lo que le queramos a\u00f1adir a Retrofit (por ejemplo un Interceptor). Aqu\u00ed tambi\u00e9n instanciamos la interfaz para que podamos usar los m\u00e9todos en nuestro c\u00f3digo.\n\n\nCreamos nuestra interfaz. La vamos a llamar \nDogService.java\n.\n\n\npublic interface DogService {\n    @GET(\nbreeds/list\n)\n    Call\nBreedWrapper\n getBreeds();\n}\n\n\n\n\nCon DogService.java estamos creando un \"puente\" entre nuestra app y la API. Cuando queramos traer todas las razas de perro, solamente tendremos que instanciar esa interfaz y usar el m\u00e9todo.\n\n\nAhora vamos a crear el cliente, \nDogClient.java\n\n\npublic class DogClient {\n    private Retrofit retrofit;\n    private final static String BASE_URL = \nhttps://dog.ceo/api/\n;\n\n    public DogClient(){\n        this.retrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n    }\n\n    public DogService getDogService(){\n        return this.retrofit.create(DogService.class);\n    }\n}\n\n\n\n\nEl cliente, nos sirve para hacer la conexi\u00f3n. Tenemos la url b\u00e1sica de la api \nhttps://dog.ceo/api/\n a la que concatenaremos los m\u00e9todos que querremos usar. Adem\u00e1s, debemos crear una instancia de Retrofit en nuestro constructor, indic\u00e1ndole la URL base y que queremos que GSON convierta los objetos JSON a objetos de Java.\n\n\nPor \u00faltimo, declaramos un m\u00e9todo que nos dar\u00e1 una instancia del servicio, con el que podremos llamar a nuestra API.", 
            "title": "Usando una API externa"
        }, 
        {
            "location": "/api/#usando-una-api-externa", 
            "text": "", 
            "title": "Usando una API externa"
        }, 
        {
            "location": "/api/#que-es-una-api", 
            "text": "Una API es una Interfaz de Programaci\u00f3n de Aplicaciones (Application Programming Interface). B\u00e1sicamente, una API es un servidor que gracias a unos m\u00e9todos en su c\u00f3digo, nos va a proveer de datos para nuestro uso.  En nuestro caso, y debido a su simplicidad, vamos a hacer una aplicaci\u00f3n que pida datos a una API sobre perros, con la que montaremos un listado y un perfil para el perro.  Nuestra API es  dogapi .", 
            "title": "Qu\u00e9 es una API"
        }, 
        {
            "location": "/api/#conexion-con-la-api", 
            "text": "Para empezar, debemos a\u00f1adir las dependencias de  Retrofit , que es la librer\u00eda que vamos a usar para la conexi\u00f3n con nuestra API. Retrofit es un cliente HTTP hecho para Java y Android.  build.gradle (Module: app)    compile  com.squareup.retrofit2:retrofit:2.3.0 \n  compile  com.squareup.retrofit2:converter-gson:2.3.0   Cuando introducimos c\u00f3digo en Gradle, tenemos que volver a sincronizar el c\u00f3digo para que los cambios sean efectivos.  Ahora creamos un nuevo Package llamado API.", 
            "title": "Conexi\u00f3n con la API"
        }, 
        {
            "location": "/api/#antes-de-retrofit", 
            "text": "Tenemos que crear nuestro modelo de datos, que nos servir\u00e1 para recoger la informaci\u00f3n del servidor.  Creamos un Package llamado entities y dentro de \u00e9l un archivo BreedWrapper.java  public class BreedWrapper {\n    @SerializedName( message )\n    private List String  breeds;\n\n    public List String  getBreeds() {\n        return breeds;\n    }\n}", 
            "title": "Antes de Retrofit"
        }, 
        {
            "location": "/api/#configurando-retrofit", 
            "text": "Cuando trabajamos con Retrofit, debemos tener dos archivos b\u00e1sicos. Uno de ellos es una interfaz donde definiremos todos los m\u00e9todos que usaremos para conectarnos a la API (por ejemplo traer todas las razas de perros o informaci\u00f3n acerca de una).  El otro es el cliente, que nos servir\u00e1 para configurar nuestra conexi\u00f3n con la API y todo lo que le queramos a\u00f1adir a Retrofit (por ejemplo un Interceptor). Aqu\u00ed tambi\u00e9n instanciamos la interfaz para que podamos usar los m\u00e9todos en nuestro c\u00f3digo.  Creamos nuestra interfaz. La vamos a llamar  DogService.java .  public interface DogService {\n    @GET( breeds/list )\n    Call BreedWrapper  getBreeds();\n}  Con DogService.java estamos creando un \"puente\" entre nuestra app y la API. Cuando queramos traer todas las razas de perro, solamente tendremos que instanciar esa interfaz y usar el m\u00e9todo.  Ahora vamos a crear el cliente,  DogClient.java  public class DogClient {\n    private Retrofit retrofit;\n    private final static String BASE_URL =  https://dog.ceo/api/ ;\n\n    public DogClient(){\n        this.retrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n    }\n\n    public DogService getDogService(){\n        return this.retrofit.create(DogService.class);\n    }\n}  El cliente, nos sirve para hacer la conexi\u00f3n. Tenemos la url b\u00e1sica de la api  https://dog.ceo/api/  a la que concatenaremos los m\u00e9todos que querremos usar. Adem\u00e1s, debemos crear una instancia de Retrofit en nuestro constructor, indic\u00e1ndole la URL base y que queremos que GSON convierta los objetos JSON a objetos de Java.  Por \u00faltimo, declaramos un m\u00e9todo que nos dar\u00e1 una instancia del servicio, con el que podremos llamar a nuestra API.", 
            "title": "Configurando Retrofit"
        }, 
        {
            "location": "/listado/", 
            "text": "Crear un listado de elementos\n\n\nC\u00f3mo hacer un listado en Android\n\n\nPara crear una lista de elementos, tenemos varias opciones. Podemos usar \nListView\n, \nRecyclerView\n, o \nGridView\n.\n\n\nNuestra implementaci\u00f3n va a ser un listado vertical con datos. Un ejemplo de lo que queremos montar ser\u00eda:\n\n\n\n\nDiferencia entre ListView y RecyclerView\n\n\nTanto el ListView como el RecyclerView nos sirven en caso de querer hacer listado como el de la imagen. Las diferencias son que el RecyclerView es una implementaci\u00f3n m\u00e1s nueva, da m\u00e1s flexibilidad con animaciones, y adem\u00e1s, como en su nombre se indica, recicla los items de la tabla por lo que supone un ahorro en memoria. El RecyclerView s\u00f3lo tiene declarados los items visibles, y uno por encima y por debajo. Cuando el usuario hace scroll, las celdas que ya no se ven se reutilizan para mostrar las nuevas.\n\n\nEn esta gu\u00eda vamos a usar RecyclerView por estas razones.", 
            "title": "Crear un listado"
        }, 
        {
            "location": "/listado/#crear-un-listado-de-elementos", 
            "text": "", 
            "title": "Crear un listado de elementos"
        }, 
        {
            "location": "/listado/#como-hacer-un-listado-en-android", 
            "text": "Para crear una lista de elementos, tenemos varias opciones. Podemos usar  ListView ,  RecyclerView , o  GridView .  Nuestra implementaci\u00f3n va a ser un listado vertical con datos. Un ejemplo de lo que queremos montar ser\u00eda:", 
            "title": "C\u00f3mo hacer un listado en Android"
        }, 
        {
            "location": "/listado/#diferencia-entre-listview-y-recyclerview", 
            "text": "Tanto el ListView como el RecyclerView nos sirven en caso de querer hacer listado como el de la imagen. Las diferencias son que el RecyclerView es una implementaci\u00f3n m\u00e1s nueva, da m\u00e1s flexibilidad con animaciones, y adem\u00e1s, como en su nombre se indica, recicla los items de la tabla por lo que supone un ahorro en memoria. El RecyclerView s\u00f3lo tiene declarados los items visibles, y uno por encima y por debajo. Cuando el usuario hace scroll, las celdas que ya no se ven se reutilizan para mostrar las nuevas.  En esta gu\u00eda vamos a usar RecyclerView por estas razones.", 
            "title": "Diferencia entre ListView y RecyclerView"
        }, 
        {
            "location": "/vista/", 
            "text": "Organizar la vista\n\n\nComo organizar nuestra vista\n\n\nAntes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.\n\n\nPara crear una vista, debemos editar el archivo \nactivity_main.xml\n que nos cre\u00f3 \nAndroid Studio\n cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase \nJava\n, infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.\n\n\nHay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de \nUI\n (\nUser Interface\n).\n\n\nPodemos tener un dise\u00f1o linar (\nLinearLayout\n) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con \nGridLayout\n o \nTableLayout\n. Hay layouts especiales para mostrar un fragment (\nFrameLayout\n). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con \nRelativeLayout\n.\n\n\n\n\nListado de razas de perro\n\n\nUna vez abramos nuestro activity_main.xml veremos que tenemos un ConstraintLayout y dentro de \u00e9l un TextView con un texto de ejemplo.\n\n\nComo no vamos a usar nada de constraints, cambiamos este por un LinearLayout, borramos el TextView y a\u00f1adimos un RecyclerView.\n\n\nSi miramos en la preview, nos dar\u00e1 un aviso de que nos falta la dependencia de RecyclerView, as\u00ed que vamos al build.gradle de app y a\u00f1adimos la siguiente l\u00ednea:\n\n\ncompile \ncom.android.support:recyclerview-v7:25.3.1\n\n\n\n\n\n\n\nNota\n\n\nCuando a\u00f1adimos una librer\u00eda a Gradle, la dependencia viene dividida en 3 partes divididas por \n:\n. La estructura de una dependencia es \nnombre-librer\u00eda:item-librer\u00eda:version\n. Cuando trabajemos con una misma librer\u00eda e importemos cosas distintas, tenemos que tener cuidado de que hay que importar la misma versi\u00f3n para todas.\n\n\n\n\nEl c\u00f3digo de nuestra vista puede ser as\u00ed:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nLinearLayout xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    xmlns:app=\nhttp://schemas.android.com/apk/res-auto\n\n    xmlns:tools=\nhttp://schemas.android.com/tools\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\nmatch_parent\n\n    tools:context=\ncom.example.david.ucoexample.MainActivity\n\n\n  \nandroid.support.v7.widget.RecyclerView\n       android:id=\n@+id/dogList\n\n       android:layout_width=\nmatch_parent\n\n       android:layout_height=\nmatch_parent\n\n\n  \n/android.support.v7.widget.RecyclerView\n\n\n\n/LinearLayout\n\n\n\n\n\nCrear item de perro\n\n\nUna vez que tenemos configurado el contenedor del listado, ahora tenemos que crear los items que vamos a mostrar. Como quedan muy curiosos, vamos a hacer CardViews, que son tarjetas implementadas por Android con la librer\u00eda de \nMaterial Design\n.\n\n\nPara crear un nuevo layout, hacemos click derecho sobre \nres/layout\n y vamos a \nNew/Layout resource file\n.\nComo nombre le pondremos \nitem_dog\n. En cuant a nomemclatura, en Android se suele poner primero si es item o alg\u00fan tipo de vista (activity, fragment) seguido de una barra baja y un nombre identificativo.\n\n\n\n\n\n\nUna vez tengramos creado nuestro layout, es hora de implementar nuestra primera CardView. Una card de Material es una hora que sirve como punto de entrada a informaci\u00f3n. En nuestro caso lo vamos a usar para listar razas de perro, que aunque es un listado sencillo y s\u00f3lo tendremos el nombre de la raza, vamos a intentar que destaque de alguna manera.\n\n\nAntes de nada, hay que ir a a\u00f1adir su dependencia:\n\n\ncompile \ncom.android.support:cardview-v7:25.3.1\n\n\n\n\n\nUna vez a\u00f1adida, la estructura b\u00e1sica de nuestro layout ser\u00eda:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nandroid.support.v7.widget.CardView\n    xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:layout_margin=\n8dp\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\n100dp\n\n\n    \nLinearLayout\n        android:orientation=\nhorizontal\n\n        android:layout_width=\nmatch_parent\n\n        android:layout_height=\nmatch_parent\n\n\n        \nImageView\n            android:src=\n@drawable/dog\n\n            android:layout_width=\n100dp\n\n            android:layout_height=\nmatch_parent\n /\n\n\n        \nTextView\n            android:id=\n@+id/dogBreedName\n\n            android:layout_width=\nwrap_content\n\n            android:layout_height=\nwrap_content\n /\n\n\n    \n/LinearLayout\n\n\n/android.support.v7.widget.CardView\n\n\n\n\n\nComo puedes ver, hemos puesto una CardView que a fin de cuentas es un contenedor del contenido interior. Dentro tenemos un LinearLayout horizontal, que tendr\u00e1 dos items, una imagen y un texto.\n\n\nPara la imagen vamos a usar una est\u00e1tica\n\n\n\n\nDebemos a\u00f1adir la imagen en \nres/drawable\n y le ponemos el nombre \ndog.png\n.", 
            "title": "Nuestra primera vista"
        }, 
        {
            "location": "/vista/#organizar-la-vista", 
            "text": "", 
            "title": "Organizar la vista"
        }, 
        {
            "location": "/vista/#como-organizar-nuestra-vista", 
            "text": "Antes de comenzar, debemos saber como est\u00e1n organizadas las vistas en Android.  Para crear una vista, debemos editar el archivo  activity_main.xml  que nos cre\u00f3  Android Studio  cuando creamos nuestro proyecto. Cada actividad o fragmento tienen que tener una vista asociada. Cuando la aplicaci\u00f3n corre nuestra clase  Java , infla la vista y la muestra al usuario. Tambi\u00e9n podemos crear los objetos de nuestra vista desde la clase Java que infla el layout.  Hay distintas formas de organizar nuestro layout. Android cuenta con una serie de contenedores que agrupar\u00e1 en contenido, y en ellos ser\u00e1 donde coloquemos nuestros elementos de  UI  ( User Interface ).  Podemos tener un dise\u00f1o linar ( LinearLayout ) que colocar\u00e1 los elementos uno detr\u00e1s de otro, bien de forma horizontal o de forma vertical. Podemos organizar nuestros elementos como en una tabla o grid (Google Fotos) con  GridLayout  o  TableLayout . Hay layouts especiales para mostrar un fragment ( FrameLayout ). Por \u00faltimo, podemos colocar nuestros elementos de forma relativa, algo as\u00ed como se hace en web, con  RelativeLayout .", 
            "title": "Como organizar nuestra vista"
        }, 
        {
            "location": "/vista/#listado-de-razas-de-perro", 
            "text": "Una vez abramos nuestro activity_main.xml veremos que tenemos un ConstraintLayout y dentro de \u00e9l un TextView con un texto de ejemplo.  Como no vamos a usar nada de constraints, cambiamos este por un LinearLayout, borramos el TextView y a\u00f1adimos un RecyclerView.  Si miramos en la preview, nos dar\u00e1 un aviso de que nos falta la dependencia de RecyclerView, as\u00ed que vamos al build.gradle de app y a\u00f1adimos la siguiente l\u00ednea:  compile  com.android.support:recyclerview-v7:25.3.1", 
            "title": "Listado de razas de perro"
        }, 
        {
            "location": "/vista/#nota", 
            "text": "Cuando a\u00f1adimos una librer\u00eda a Gradle, la dependencia viene dividida en 3 partes divididas por  : . La estructura de una dependencia es  nombre-librer\u00eda:item-librer\u00eda:version . Cuando trabajemos con una misma librer\u00eda e importemos cosas distintas, tenemos que tener cuidado de que hay que importar la misma versi\u00f3n para todas.   El c\u00f3digo de nuestra vista puede ser as\u00ed:  ?xml version= 1.0  encoding= utf-8 ?  LinearLayout xmlns:android= http://schemas.android.com/apk/res/android \n    xmlns:app= http://schemas.android.com/apk/res-auto \n    xmlns:tools= http://schemas.android.com/tools \n    android:layout_width= match_parent \n    android:layout_height= match_parent \n    tools:context= com.example.david.ucoexample.MainActivity \n\n   android.support.v7.widget.RecyclerView\n       android:id= @+id/dogList \n       android:layout_width= match_parent \n       android:layout_height= match_parent \n\n   /android.support.v7.widget.RecyclerView  /LinearLayout", 
            "title": "Nota"
        }, 
        {
            "location": "/vista/#crear-item-de-perro", 
            "text": "Una vez que tenemos configurado el contenedor del listado, ahora tenemos que crear los items que vamos a mostrar. Como quedan muy curiosos, vamos a hacer CardViews, que son tarjetas implementadas por Android con la librer\u00eda de  Material Design .  Para crear un nuevo layout, hacemos click derecho sobre  res/layout  y vamos a  New/Layout resource file .\nComo nombre le pondremos  item_dog . En cuant a nomemclatura, en Android se suele poner primero si es item o alg\u00fan tipo de vista (activity, fragment) seguido de una barra baja y un nombre identificativo.    Una vez tengramos creado nuestro layout, es hora de implementar nuestra primera CardView. Una card de Material es una hora que sirve como punto de entrada a informaci\u00f3n. En nuestro caso lo vamos a usar para listar razas de perro, que aunque es un listado sencillo y s\u00f3lo tendremos el nombre de la raza, vamos a intentar que destaque de alguna manera.  Antes de nada, hay que ir a a\u00f1adir su dependencia:  compile  com.android.support:cardview-v7:25.3.1   Una vez a\u00f1adida, la estructura b\u00e1sica de nuestro layout ser\u00eda:  ?xml version= 1.0  encoding= utf-8 ?  android.support.v7.widget.CardView\n    xmlns:android= http://schemas.android.com/apk/res/android \n    android:layout_margin= 8dp \n    android:layout_width= match_parent \n    android:layout_height= 100dp \n\n     LinearLayout\n        android:orientation= horizontal \n        android:layout_width= match_parent \n        android:layout_height= match_parent \n\n         ImageView\n            android:src= @drawable/dog \n            android:layout_width= 100dp \n            android:layout_height= match_parent  / \n\n         TextView\n            android:id= @+id/dogBreedName \n            android:layout_width= wrap_content \n            android:layout_height= wrap_content  / \n\n     /LinearLayout  /android.support.v7.widget.CardView   Como puedes ver, hemos puesto una CardView que a fin de cuentas es un contenedor del contenido interior. Dentro tenemos un LinearLayout horizontal, que tendr\u00e1 dos items, una imagen y un texto.  Para la imagen vamos a usar una est\u00e1tica   Debemos a\u00f1adir la imagen en  res/drawable  y le ponemos el nombre  dog.png .", 
            "title": "Crear item de perro"
        }, 
        {
            "location": "/inflando_vista/", 
            "text": "Inflando la vista\n\n\nQu\u00e9 es inflar una vista\n\n\n\u00bfQue significa inflar la vista? B\u00e1sicamente es rellenar nuestros layouts con datos. Los datos que vamos a mostrar son las razas de perro que nos traeremos con Retrofit.\n\n\nVamos a nuestra actividad y creamos las siguientes funciones:\n\n\nprivate void setAdapter(){\n  //aqui configuraremos el adaptador de nuestros datos\n}\n\nprivate void setRecyclerView(){\n  //aqui inicializaremos nuestro recyclerview\n}\n\nprivate void getDogBreeds(){\n  //desde aqu\u00ed llamaremos al servidor y traeremos los datos\n}\n\n\n\n\nPara poder inicializar el \nRecyclerView\n, tenemos que hacer un \nbinding\n. Un binding es hacer referencia al layout desde nuestra clase Java. Tenemos una forma nativa del SDK que puede resultar bastante tediosa.\n\n\n  private RecyclerView recyclerView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState){\n    ...\n\n    recyclerView = (RecyclerView) findViewById(R.id.dogList);\n  }\n\n\n\n\nOtra forma, mucho m\u00e1s sencilla, es hacerlo con \nButterknife\n. Con Butterknife nos ahorramos hacer el \nfindViewById()\n y si instalamos el plugin correspondiente en Android Studio no tenemos que llegar a escribir nada.\n\n\nPara instalar Butterknife, a\u00f1adimos la dependencia:\n\n\ncompile 'com.jakewharton:butterknife:8.8.1'\nannotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'\n\n\n\n\nUna vez a\u00f1adida la dependencia, debemos dejar la clase as\u00ed:\n\n\npublic class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.dogList)\n    RecyclerView dogList;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.bind(this);\n    }\n\n    private void setAdapter() {\n\n    }\n\n    private void setRecyclerView() {\n\n    }\n\n    private void getDogBreeds() {\n\n    }\n}\n\n\n\n\nComo v\u00e9is, es necesario hacer \nButterKnife.bind(this);\n justo despu\u00e9s de hacer el \nsetContentView()\n. Esto es as\u00ed ya que con ese m\u00e9todo, Butterknife hace por su cuenta los \nfindViewById()\n.\n\n\nDeclarar el adapter\n\n\nUn adapter es una clase intermedia entre nuestro layout y los datos. Nos ayuda a distribuir la informaci\u00f3n en el layout y lo administra internamente. Si tenemos un listado muy grande, el Adapter ir\u00e1 creando cada item del listado y reciclando los que ya no se ven en pantalla. Se encarga de, a partir de un array de datos, setear los textos, im\u00e1genes, colores o cualquier cosa que queramos editar en nuestros layouts.\n\n\nPara crear el adaptador, creamos un nuevo package llamado \nadapter\n y dentro de \u00e9l creamos una nueva clase de Java llamada \nDogListAdapter.java\n.\n\n\nPara que una clase de Java sea un adaptador, debe heredar de \nRecyclerView.Adapter\n e implementar un ViewHolder. Un ViewHolder es la clase del elemento que estamos mostrando. En nuestro caso, nuestro ViewHolder ser\u00e1 una clase con un campo \nString\n que ser\u00e1 la raza de perro que estemos mostrando.\n\n\nNuestra clase se quedar\u00e1 as\u00ed:\n\n\npublic class DogListAdapter extends RecyclerView.Adapter\nDogListAdapter.ViewHolder\n {\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        return null;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n\n    }\n\n    @Override\n    public int getItemCount() {\n        return 0;\n    }\n\n\n    public class ViewHolder extends RecyclerView.ViewHolder {\n        public ViewHolder(View itemView) {\n            super(itemView);\n        }\n    }\n}\n\n\n\n\nTodos esos m\u00e9todos son obligatorios implementarlos:\n\n\n\n\n\n\nonCreateViewHolder\n: este m\u00e9todo se dispara cuando el adaptador va a crear un item. Aqu\u00ed normalmente lo que hacemos es decirle al adaptador qu\u00e9 layout debe usar para mostrar en pantalla.\n\n\n\n\n\n\nonBindViewHolder\n: aqu\u00ed, el elemento ya est\u00e1 creado, pero est\u00e1 vac\u00edo. Nos sirve para setear los datos que queremos mostrar, o asignar los eventos de onClick o alguna cosa que necesitemos.\n\n\n\n\n\n\ngetItemCount\n: este m\u00e9todo es super importante, ya que aqu\u00ed el adaptador sabe cuantas veces debe disparar los dos m\u00e9todos de arriba. Si nos equivocamos y siempre retorna 0, nunca se nos mostrar\u00e1 nada en pantalla. Normalmente, lo que se hace es crear un array interno de elementos, setear los valores a ese array y luego retornar aqu\u00ed su tama\u00f1o.\n\n\n\n\n\n\nClase ViewHolder\n: como hemos dicho, es una clase que nos sirve para bindear los campos que vamos a mostrar en pantalla.\n\n\n\n\n\n\nRellenar el Adapter con datos\n\n\nLo primero de todo, necesitamos un array de string para guardar las razas de perro.\n\n\nprivate List\nString\n dogBreeds;\n\n\n\n\nY creamos un m\u00e9todo para poder insertar los datos desde la actividad, que es donde los vamos a traer.\n\n\npublic void setDogBreeds(List\nString\n dogBreedsArray){\n    this.dogBreeds = dogBreedsArray;\n    this.notifyDataSetChanged();\n}\n\n\n\n\nLa llamada \nthis.notifyDataSetChanged()\n nos sirve para reiniciar el adapter, y que se vuelvan a disparar los m\u00e9todos de \nonCreateViewHolder\n y \nonBindViewHolder\n.\n\n\nTambi\u00e9n tenemos que cambiar el m\u00e9todo \ngetItemCount\n para que retorne el tama\u00f1o de ese array y no 0.\n\n\n@Override\npublic int getItemCount() {\n    return this.dogBreeds.size();\n}\n\n\n\n\nAsignando el layout al adapter\n\n\nDebemos cambiar el m\u00e9todo \nonCreateViewHolder\n y dejarlo asi:\n\n\n@Override\npublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_dog, parent, false);\n\n    return new ViewHolder(view);\n}\n\n\n\n\nEstamos usando la clase \nLayoutInflater\n para coger el layout que hemos hecho antes de \nitem_dog\n y asignarselo al item que estamos creando.\n\n\nAsignando los datos\n\n\nUsando ButterKnife, debemos a\u00f1adir al ViewHolder el campo de TextView que antes hemos creado en el layout.\n\n\npublic class ViewHolder extends RecyclerView.ViewHolder {\n\n    //seteamos el valor aqu\u00ed\n    @BindView(R.id.dogBreedName)\n    TextView dogBreedName;\n\n    private View view;\n\n    public ViewHolder(View itemView) {\n        super(itemView);\n        ButterKnife.bind(this, itemView);\n        this.view = itemView;\n    }\n}\n\n\n\n\nAhora en \nonBindViewHolder\n rellenamos el TextView con el valor que corresponda:\n\n\n@Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    holder.dogBreedName.setText(this.dogBreeds.get(position));\n}\n\n\n\n\nPor \u00faltimo, nos queda declarar en el constructor el array vac\u00edo, para que no tengamos un error al asignar valores a algo que est\u00e1 a null (NullPointerException)\n\n\npublic DogListAdapter() {\n    this.dogBreeds = new ArrayList\n();\n}", 
            "title": "Inflando la vista"
        }, 
        {
            "location": "/inflando_vista/#inflando-la-vista", 
            "text": "", 
            "title": "Inflando la vista"
        }, 
        {
            "location": "/inflando_vista/#que-es-inflar-una-vista", 
            "text": "\u00bfQue significa inflar la vista? B\u00e1sicamente es rellenar nuestros layouts con datos. Los datos que vamos a mostrar son las razas de perro que nos traeremos con Retrofit.  Vamos a nuestra actividad y creamos las siguientes funciones:  private void setAdapter(){\n  //aqui configuraremos el adaptador de nuestros datos\n}\n\nprivate void setRecyclerView(){\n  //aqui inicializaremos nuestro recyclerview\n}\n\nprivate void getDogBreeds(){\n  //desde aqu\u00ed llamaremos al servidor y traeremos los datos\n}  Para poder inicializar el  RecyclerView , tenemos que hacer un  binding . Un binding es hacer referencia al layout desde nuestra clase Java. Tenemos una forma nativa del SDK que puede resultar bastante tediosa.    private RecyclerView recyclerView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState){\n    ...\n\n    recyclerView = (RecyclerView) findViewById(R.id.dogList);\n  }  Otra forma, mucho m\u00e1s sencilla, es hacerlo con  Butterknife . Con Butterknife nos ahorramos hacer el  findViewById()  y si instalamos el plugin correspondiente en Android Studio no tenemos que llegar a escribir nada.  Para instalar Butterknife, a\u00f1adimos la dependencia:  compile 'com.jakewharton:butterknife:8.8.1'\nannotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'  Una vez a\u00f1adida la dependencia, debemos dejar la clase as\u00ed:  public class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.dogList)\n    RecyclerView dogList;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.bind(this);\n    }\n\n    private void setAdapter() {\n\n    }\n\n    private void setRecyclerView() {\n\n    }\n\n    private void getDogBreeds() {\n\n    }\n}  Como v\u00e9is, es necesario hacer  ButterKnife.bind(this);  justo despu\u00e9s de hacer el  setContentView() . Esto es as\u00ed ya que con ese m\u00e9todo, Butterknife hace por su cuenta los  findViewById() .", 
            "title": "Qu\u00e9 es inflar una vista"
        }, 
        {
            "location": "/inflando_vista/#declarar-el-adapter", 
            "text": "Un adapter es una clase intermedia entre nuestro layout y los datos. Nos ayuda a distribuir la informaci\u00f3n en el layout y lo administra internamente. Si tenemos un listado muy grande, el Adapter ir\u00e1 creando cada item del listado y reciclando los que ya no se ven en pantalla. Se encarga de, a partir de un array de datos, setear los textos, im\u00e1genes, colores o cualquier cosa que queramos editar en nuestros layouts.  Para crear el adaptador, creamos un nuevo package llamado  adapter  y dentro de \u00e9l creamos una nueva clase de Java llamada  DogListAdapter.java .  Para que una clase de Java sea un adaptador, debe heredar de  RecyclerView.Adapter  e implementar un ViewHolder. Un ViewHolder es la clase del elemento que estamos mostrando. En nuestro caso, nuestro ViewHolder ser\u00e1 una clase con un campo  String  que ser\u00e1 la raza de perro que estemos mostrando.  Nuestra clase se quedar\u00e1 as\u00ed:  public class DogListAdapter extends RecyclerView.Adapter DogListAdapter.ViewHolder  {\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        return null;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n\n    }\n\n    @Override\n    public int getItemCount() {\n        return 0;\n    }\n\n\n    public class ViewHolder extends RecyclerView.ViewHolder {\n        public ViewHolder(View itemView) {\n            super(itemView);\n        }\n    }\n}  Todos esos m\u00e9todos son obligatorios implementarlos:    onCreateViewHolder : este m\u00e9todo se dispara cuando el adaptador va a crear un item. Aqu\u00ed normalmente lo que hacemos es decirle al adaptador qu\u00e9 layout debe usar para mostrar en pantalla.    onBindViewHolder : aqu\u00ed, el elemento ya est\u00e1 creado, pero est\u00e1 vac\u00edo. Nos sirve para setear los datos que queremos mostrar, o asignar los eventos de onClick o alguna cosa que necesitemos.    getItemCount : este m\u00e9todo es super importante, ya que aqu\u00ed el adaptador sabe cuantas veces debe disparar los dos m\u00e9todos de arriba. Si nos equivocamos y siempre retorna 0, nunca se nos mostrar\u00e1 nada en pantalla. Normalmente, lo que se hace es crear un array interno de elementos, setear los valores a ese array y luego retornar aqu\u00ed su tama\u00f1o.    Clase ViewHolder : como hemos dicho, es una clase que nos sirve para bindear los campos que vamos a mostrar en pantalla.", 
            "title": "Declarar el adapter"
        }, 
        {
            "location": "/inflando_vista/#rellenar-el-adapter-con-datos", 
            "text": "Lo primero de todo, necesitamos un array de string para guardar las razas de perro.  private List String  dogBreeds;  Y creamos un m\u00e9todo para poder insertar los datos desde la actividad, que es donde los vamos a traer.  public void setDogBreeds(List String  dogBreedsArray){\n    this.dogBreeds = dogBreedsArray;\n    this.notifyDataSetChanged();\n}  La llamada  this.notifyDataSetChanged()  nos sirve para reiniciar el adapter, y que se vuelvan a disparar los m\u00e9todos de  onCreateViewHolder  y  onBindViewHolder .  Tambi\u00e9n tenemos que cambiar el m\u00e9todo  getItemCount  para que retorne el tama\u00f1o de ese array y no 0.  @Override\npublic int getItemCount() {\n    return this.dogBreeds.size();\n}", 
            "title": "Rellenar el Adapter con datos"
        }, 
        {
            "location": "/inflando_vista/#asignando-el-layout-al-adapter", 
            "text": "Debemos cambiar el m\u00e9todo  onCreateViewHolder  y dejarlo asi:  @Override\npublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_dog, parent, false);\n\n    return new ViewHolder(view);\n}  Estamos usando la clase  LayoutInflater  para coger el layout que hemos hecho antes de  item_dog  y asignarselo al item que estamos creando.", 
            "title": "Asignando el layout al adapter"
        }, 
        {
            "location": "/inflando_vista/#asignando-los-datos", 
            "text": "Usando ButterKnife, debemos a\u00f1adir al ViewHolder el campo de TextView que antes hemos creado en el layout.  public class ViewHolder extends RecyclerView.ViewHolder {\n\n    //seteamos el valor aqu\u00ed\n    @BindView(R.id.dogBreedName)\n    TextView dogBreedName;\n\n    private View view;\n\n    public ViewHolder(View itemView) {\n        super(itemView);\n        ButterKnife.bind(this, itemView);\n        this.view = itemView;\n    }\n}  Ahora en  onBindViewHolder  rellenamos el TextView con el valor que corresponda:  @Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    holder.dogBreedName.setText(this.dogBreeds.get(position));\n}  Por \u00faltimo, nos queda declarar en el constructor el array vac\u00edo, para que no tengamos un error al asignar valores a algo que est\u00e1 a null (NullPointerException)  public DogListAdapter() {\n    this.dogBreeds = new ArrayList ();\n}", 
            "title": "Asignando los datos"
        }, 
        {
            "location": "/pidiendo_datos/", 
            "text": "Haciendo una petici\u00f3n al servidor\n\n\nUsando Retrofit para pedir datos\n\n\nVamos a nuestra actividad, y vamos a comenzar a traer datos de la api. Para empezar, debemos asignar un objeto de cliente Retrofit que hemos creado en anteriores pasos:\n\n\n  private DogClient client;\n\n\n\n\nVamos a crear un constructor, donde vamos a instanciar el objeto:\n\n\npublic MainActivity() {\n    client = new DogClient();\n}\n\n\n\n\nY ahora en nuestro m\u00e9todo \ngetDogBreeds\n hacemos la petici\u00f3n con Retrofit:\n\n\nprivate void getDogBreeds() {\n    client.getDogService().getBreeds().enqueue(new Callback\nBreedWrapper\n() {\n        @Override\n        public void onResponse(Call\nBreedWrapper\n call, Response\nBreedWrapper\n response) {\n\n        }\n\n        @Override\n        public void onFailure(Call\nBreedWrapper\n call, Throwable t) {\n\n        }\n    });\n}\n\n\n\n\nComo se puede ver, tenemos dos m\u00e9todos internos. Uno es \nonResponse\n que se dispar\u00e1 cuando la llamada sea \u00e9xito (da igual si el c\u00f3digo HTTP es 200 o 404) y la otra cuando falle por alguna raz\u00f3n como que la url no es v\u00e1lida o no tenemos red.\n\n\nAhora vamos a nuestro m\u00e9todo \nonCreate()\n y a\u00f1adimos la llamada a nuestro m\u00e9todo:\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    ButterKnife.bind(this);\n\n    getDogBreeds();\n}\n\n\n\n\nCuando lo tengamos, lanzamos la app en nuestro dispositivo o simulador.\n\n\n\n\nUps!\n\n\nTenemos un fallo! Cuando vamos a realizar seg\u00fan que acciones, tenemos que habilitar permisos o hacer que el usuario nos habilite. En este caso, nos falta el permiso de red, as\u00ed que para poder habilitarlo vamos a nuestro \nAndroidManifest.xml\n y a\u00f1adimos la siguiente l\u00ednea justo encima del tag \n.\n\n\nuses-permission android:name=\nandroid.permission.INTERNET\n /\n\n\n\n\n\nSi ahora volvemos a lanzar la app, ya no nos dar\u00e1 el fallo.\n\n\n\n\nRellenando el RecyclerView\n\n\nPrimero, debemos declarar el objeto del adapter:\n\n\n  private DogListAdapter adapter;\n\n\n\n\nY lo instanciamos en el m\u00e9todo de \nsetAdapter\n\n\nprivate void setAdapter() {\n    adapter = new DogListAdapter();\n}\n\n\n\n\nTambi\u00e9n tenemos que instanciar el RecyclerView:\n\n\nprivate void setRecyclerView() {\n    dogList.setLayoutManager(new LinearLayoutManager(this));\n    dogList.setAdapter(adapter);\n}\n\n\n\n\nHay dos par\u00e1metros b\u00e1sicos:\n\n\n\n\n\n\nLayout Manager\n: b\u00e1sicamente es como el RecyclerView va a mostrar los datos. En nuestro caso queremos un listado linear (por defecto es vertical), pero puede ser un GridLayout o incluso en varias columnas.\n\n\n\n\n\n\nAdaptador\n: es el adaptador que le va a proveer los datos para mostrar.\n\n\n\n\n\n\nPor \u00faltimo, queda a\u00f1adir en el \nonResponse\n lo que queremos hacer:\n\n\n@Override\npublic void onResponse(Call\nBreedWrapper\n call, Response\nBreedWrapper\n response) {\n    adapter.setDogBreeds(response.body().getBreeds());\n}\n\n\n\n\nSi lanzamos la app nos debe de salir una primera versi\u00f3n de nuestro listado.", 
            "title": "Haciendo una petici\u00f3n al servidor"
        }, 
        {
            "location": "/pidiendo_datos/#haciendo-una-peticion-al-servidor", 
            "text": "", 
            "title": "Haciendo una petici\u00f3n al servidor"
        }, 
        {
            "location": "/pidiendo_datos/#usando-retrofit-para-pedir-datos", 
            "text": "Vamos a nuestra actividad, y vamos a comenzar a traer datos de la api. Para empezar, debemos asignar un objeto de cliente Retrofit que hemos creado en anteriores pasos:    private DogClient client;  Vamos a crear un constructor, donde vamos a instanciar el objeto:  public MainActivity() {\n    client = new DogClient();\n}  Y ahora en nuestro m\u00e9todo  getDogBreeds  hacemos la petici\u00f3n con Retrofit:  private void getDogBreeds() {\n    client.getDogService().getBreeds().enqueue(new Callback BreedWrapper () {\n        @Override\n        public void onResponse(Call BreedWrapper  call, Response BreedWrapper  response) {\n\n        }\n\n        @Override\n        public void onFailure(Call BreedWrapper  call, Throwable t) {\n\n        }\n    });\n}  Como se puede ver, tenemos dos m\u00e9todos internos. Uno es  onResponse  que se dispar\u00e1 cuando la llamada sea \u00e9xito (da igual si el c\u00f3digo HTTP es 200 o 404) y la otra cuando falle por alguna raz\u00f3n como que la url no es v\u00e1lida o no tenemos red.  Ahora vamos a nuestro m\u00e9todo  onCreate()  y a\u00f1adimos la llamada a nuestro m\u00e9todo:  @Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    ButterKnife.bind(this);\n\n    getDogBreeds();\n}  Cuando lo tengamos, lanzamos la app en nuestro dispositivo o simulador.", 
            "title": "Usando Retrofit para pedir datos"
        }, 
        {
            "location": "/pidiendo_datos/#ups", 
            "text": "Tenemos un fallo! Cuando vamos a realizar seg\u00fan que acciones, tenemos que habilitar permisos o hacer que el usuario nos habilite. En este caso, nos falta el permiso de red, as\u00ed que para poder habilitarlo vamos a nuestro  AndroidManifest.xml  y a\u00f1adimos la siguiente l\u00ednea justo encima del tag  .  uses-permission android:name= android.permission.INTERNET  /   Si ahora volvemos a lanzar la app, ya no nos dar\u00e1 el fallo.", 
            "title": "Ups!"
        }, 
        {
            "location": "/pidiendo_datos/#rellenando-el-recyclerview", 
            "text": "Primero, debemos declarar el objeto del adapter:    private DogListAdapter adapter;  Y lo instanciamos en el m\u00e9todo de  setAdapter  private void setAdapter() {\n    adapter = new DogListAdapter();\n}  Tambi\u00e9n tenemos que instanciar el RecyclerView:  private void setRecyclerView() {\n    dogList.setLayoutManager(new LinearLayoutManager(this));\n    dogList.setAdapter(adapter);\n}  Hay dos par\u00e1metros b\u00e1sicos:    Layout Manager : b\u00e1sicamente es como el RecyclerView va a mostrar los datos. En nuestro caso queremos un listado linear (por defecto es vertical), pero puede ser un GridLayout o incluso en varias columnas.    Adaptador : es el adaptador que le va a proveer los datos para mostrar.    Por \u00faltimo, queda a\u00f1adir en el  onResponse  lo que queremos hacer:  @Override\npublic void onResponse(Call BreedWrapper  call, Response BreedWrapper  response) {\n    adapter.setDogBreeds(response.body().getBreeds());\n}  Si lanzamos la app nos debe de salir una primera versi\u00f3n de nuestro listado.", 
            "title": "Rellenando el RecyclerView"
        }, 
        {
            "location": "/nueva_actividad/", 
            "text": "Abrir una nueva actividad\n\n\nPrimeros pasos\n\n\nPara crear la actividad pulsamos sobre el package de nuestra app, click derecho, New -\n Activity -\n Empty Activity. Le ponemos como nombre \nDogDetailsActivity\n.\n\n\n\n\nHemos marcado las opciones de que nos cree un layout propio para actividad y que sea retrocompatible con otras versiones de Android.\n\n\n\n\nNota\n\n\nCuando agregamos una actividad, esta se debe de dar de alta en el \nAndroidManifest.xml\n. Al crearla de la forma indicada Android Studio lo har\u00e1 por nosotros, pero si lo hacemos nosotros a mano tenemos que tenerlo en cuenta.\n\n\n\n\nYa que nuestra app tiene un listado de items, ahora el siguiente paso es hacer que al pulsar en uno de ellos el item nos diriga a una pantalla donde nos de m\u00e1s informaci\u00f3n de la raza elegida.\n\n\nPrimero, vamos a crear una interfaz llamada \nonClickOnItem\n.\n\n\n\u00bfPor qu\u00e9 usamos interfaces?\n\n\nLas interfaces sirven como contratos para que una clase implemente ciertas funciones. Nos sirve para definir como interactuar con las clases en caso de que hagamos una librer\u00eda o pueden servirnos para ordenar nuestro propio c\u00f3digo, ya que obligamos a que nuestra clase cumpla una determinada especificaci\u00f3n de requisitos.\n\n\nUna interfaz simplemente lista funciones, que a su vez ser\u00e1n implementadas por una clase. Hay que tener cuidado y hacer las interfaces lo m\u00e1s b\u00e1sicas posibles, ya que sino podemos tener funciones vac\u00edas en nuestra clase que no nos sirven para nada (violaci\u00f3n del Principio de Liskov).\n\n\nEn nuestra interfaz, vamos a definir un m\u00e9todo llamado \nonClickBreed()\n\n\npublic interface OnClickOnItem {\n    public void onClickBreed();\n}\n\n\n\n\n\n\nNota\n\n\nPodemos llamar a nuestra interfaz como queramos, incluso OnClick, pero para evitar que haya equivocaci\u00f3n con la OnClick de Butterknife elegimos OnClickOnItem.\n\n\n\n\nCuando vamos a setear un evento de click, tenemos que cumplir dos pasos:\n\n\n\n\nHay que declarar el evento \nonClickListener\n en el layout que queremos pulsar.\n\n\nHay que implementar el m\u00e9todo de click (en nuestro caso \nonClickBreed\n) en la actividad, adapter o fragment correspondiente.\n\n\n\n\nAsignando el evento\n\n\nNos vamos a nuestro adapter, y declaramos el siguiente m\u00e9todo dentro de nuestro ViewHolder:\n\n\npublic void setOnClickListener(final OnClickOnItem onClick){\n    itemView.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View view) {\n            onClick.onClickBreed();\n        }\n    });\n}\n\n\n\n\nNuestra variable \nitemView\n es nuestra vista completa, es decir, toda la vista que engloba al CardView y los elementos que van dentro. Lo hacemos as\u00ed para que, pulsemos donde pulsemos, el evento se dispare. Podemos tener un evento distinto para cada item de la CardView si queremos, pero no es el caso.\n\n\nAhora, para que el adapter llame a la actividad, primero debe recibir por constructor una instancia de la clase que implementa este interface \nOnClickOnItem\n.\n\n\nPara ello, vamos a nuestro adaptador y a\u00f1adimos un par\u00e1metro OnClickOnItem:\n\n\nprivate OnClickOnItem onClick;\n\npublic DogListAdapter(OnClickOnItem onClick) {\n    ...\n    this.onClick = onClick;\n}\n\n\n\n\nPor \u00faltimo en nuestro adaptador, vamos al m\u00e9todo \nonBindViewHolder\n y seteamos el evento de esta manera:\n\n\n@Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    ...\n    holder.setOnClickListener(onClick);\n}\n\n\n\n\nCon esto, ya enlazamos la funci\u00f3n de onClick que vamos a implementar en la actividad con el item.\n\n\nAsignando el evento en la actividad\n\n\nUna vez que el item dispare el evento, acto seguido se dispar\u00e1 la funci\u00f3n en la actividad.\n\n\nSi abrimos el archivo de MainActivity.java, vamos a notar que tenemos un error a la hora de declarar el adaptador. Eso es porque no estamos pasando una instancia de la interfaz.\n\n\nPara arreglarlo, primero la actividad tiene que implementar la interfaz.\n\n\npublic class MainActivity extends AppCompatActivity implements OnClickOnItem{\n\n}\n\n\n\n\nAhora, veremos como se subraya de rojo. Eso es debido a que estamos implementando una intefaz pero no hemos declarado la funci\u00f3n que nos obliga a implementar (contrato de la interfaz). Escribimos la funci\u00f3n o hacemos que AS nos la genere (Alt + Enter).\n\n\nAhora que ya tenemos la funci\u00f3n, podemos pasar una instancia de la intefaz.\n\n\n\n\nNota\n\n\nUna vez que la clase implementa una intefaz, podemos pasar la instancia de la interfaz a otras clases usando el objeto \nthis\n (Programaci\u00f3n orientada a objetos). B\u00e1sicamente, cuando implementamos una interfaz, toda su implementaci\u00f3n se suma a la clase.\n\n\n\n\nAhora, pasamos la instancia al adaptador:\n\n\nprivate void setAdapter() {\n    adapter = new DogListAdapter(this);\n}\n\n\n\n\nPor \u00faltimo, abrimos la nueva actividad. Para ello debemos trabajar con los intents.\n\n\n\u00bfQu\u00e9 es un intent?\n\n\nSeg\u00fan la \ndocumentaci\u00f3n de Android\n, un intent es \nun objeto de acci\u00f3n que puedes usar para solicitar una acci\u00f3n de otro componente de la aplicaci\u00f3n\n . Hay dos tipos de Intents:\n\n\n\n\nExpl\u00edcitos: especifican que componente queremos abrir seg\u00fan su nombre (nombre de clase). Las usamos para abrir nuevas actividades de nuestra aplicaci\u00f3n.\n\n\nImpl\u00edcitos: aqu\u00ed no se especifica qu\u00e9 componente vamos a abrir pero declara una acci\u00f3n general a realizar. Por ejemplo el abrir un mapa o el compartir algo por una red social.\n\n\n\n\nDeclarando nuestro intent para abrir otra actividad\n\n\nNos vamos a nuestra funci\u00f3n \nonClickBreed()\n y a\u00f1adimos el siguiente c\u00f3digo:\n\n\n@Override\npublic void onClickBreed() {\n    Intent intent = new Intent(this, DogDetailsActivity.class);\n    startActivity(intent);\n}\n\n\n\n\nAhora si probamos la app podremos abrir la nueva actividad.\n\n\n\n\nExtra\n\n\nComo curiosidad, si vamos a nuestro AndroidManifest.xml y a\u00f1adimos la siguiente propiedad a nuestra nueva actividad nos aparecer\u00e1 la flecha para ir hacia atr\u00e1s.\n\n\nandroid:parentActivityName=\n.MainActivity", 
            "title": "Abrir una nueva actividad"
        }, 
        {
            "location": "/nueva_actividad/#abrir-una-nueva-actividad", 
            "text": "", 
            "title": "Abrir una nueva actividad"
        }, 
        {
            "location": "/nueva_actividad/#primeros-pasos", 
            "text": "Para crear la actividad pulsamos sobre el package de nuestra app, click derecho, New -  Activity -  Empty Activity. Le ponemos como nombre  DogDetailsActivity .   Hemos marcado las opciones de que nos cree un layout propio para actividad y que sea retrocompatible con otras versiones de Android.", 
            "title": "Primeros pasos"
        }, 
        {
            "location": "/nueva_actividad/#nota", 
            "text": "Cuando agregamos una actividad, esta se debe de dar de alta en el  AndroidManifest.xml . Al crearla de la forma indicada Android Studio lo har\u00e1 por nosotros, pero si lo hacemos nosotros a mano tenemos que tenerlo en cuenta.   Ya que nuestra app tiene un listado de items, ahora el siguiente paso es hacer que al pulsar en uno de ellos el item nos diriga a una pantalla donde nos de m\u00e1s informaci\u00f3n de la raza elegida.  Primero, vamos a crear una interfaz llamada  onClickOnItem .", 
            "title": "Nota"
        }, 
        {
            "location": "/nueva_actividad/#por-que-usamos-interfaces", 
            "text": "Las interfaces sirven como contratos para que una clase implemente ciertas funciones. Nos sirve para definir como interactuar con las clases en caso de que hagamos una librer\u00eda o pueden servirnos para ordenar nuestro propio c\u00f3digo, ya que obligamos a que nuestra clase cumpla una determinada especificaci\u00f3n de requisitos.  Una interfaz simplemente lista funciones, que a su vez ser\u00e1n implementadas por una clase. Hay que tener cuidado y hacer las interfaces lo m\u00e1s b\u00e1sicas posibles, ya que sino podemos tener funciones vac\u00edas en nuestra clase que no nos sirven para nada (violaci\u00f3n del Principio de Liskov).  En nuestra interfaz, vamos a definir un m\u00e9todo llamado  onClickBreed()  public interface OnClickOnItem {\n    public void onClickBreed();\n}", 
            "title": "\u00bfPor qu\u00e9 usamos interfaces?"
        }, 
        {
            "location": "/nueva_actividad/#nota_1", 
            "text": "Podemos llamar a nuestra interfaz como queramos, incluso OnClick, pero para evitar que haya equivocaci\u00f3n con la OnClick de Butterknife elegimos OnClickOnItem.   Cuando vamos a setear un evento de click, tenemos que cumplir dos pasos:   Hay que declarar el evento  onClickListener  en el layout que queremos pulsar.  Hay que implementar el m\u00e9todo de click (en nuestro caso  onClickBreed ) en la actividad, adapter o fragment correspondiente.", 
            "title": "Nota"
        }, 
        {
            "location": "/nueva_actividad/#asignando-el-evento", 
            "text": "Nos vamos a nuestro adapter, y declaramos el siguiente m\u00e9todo dentro de nuestro ViewHolder:  public void setOnClickListener(final OnClickOnItem onClick){\n    itemView.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View view) {\n            onClick.onClickBreed();\n        }\n    });\n}  Nuestra variable  itemView  es nuestra vista completa, es decir, toda la vista que engloba al CardView y los elementos que van dentro. Lo hacemos as\u00ed para que, pulsemos donde pulsemos, el evento se dispare. Podemos tener un evento distinto para cada item de la CardView si queremos, pero no es el caso.  Ahora, para que el adapter llame a la actividad, primero debe recibir por constructor una instancia de la clase que implementa este interface  OnClickOnItem .  Para ello, vamos a nuestro adaptador y a\u00f1adimos un par\u00e1metro OnClickOnItem:  private OnClickOnItem onClick;\n\npublic DogListAdapter(OnClickOnItem onClick) {\n    ...\n    this.onClick = onClick;\n}  Por \u00faltimo en nuestro adaptador, vamos al m\u00e9todo  onBindViewHolder  y seteamos el evento de esta manera:  @Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    ...\n    holder.setOnClickListener(onClick);\n}  Con esto, ya enlazamos la funci\u00f3n de onClick que vamos a implementar en la actividad con el item.", 
            "title": "Asignando el evento"
        }, 
        {
            "location": "/nueva_actividad/#asignando-el-evento-en-la-actividad", 
            "text": "Una vez que el item dispare el evento, acto seguido se dispar\u00e1 la funci\u00f3n en la actividad.  Si abrimos el archivo de MainActivity.java, vamos a notar que tenemos un error a la hora de declarar el adaptador. Eso es porque no estamos pasando una instancia de la interfaz.  Para arreglarlo, primero la actividad tiene que implementar la interfaz.  public class MainActivity extends AppCompatActivity implements OnClickOnItem{\n\n}  Ahora, veremos como se subraya de rojo. Eso es debido a que estamos implementando una intefaz pero no hemos declarado la funci\u00f3n que nos obliga a implementar (contrato de la interfaz). Escribimos la funci\u00f3n o hacemos que AS nos la genere (Alt + Enter).  Ahora que ya tenemos la funci\u00f3n, podemos pasar una instancia de la intefaz.", 
            "title": "Asignando el evento en la actividad"
        }, 
        {
            "location": "/nueva_actividad/#nota_2", 
            "text": "Una vez que la clase implementa una intefaz, podemos pasar la instancia de la interfaz a otras clases usando el objeto  this  (Programaci\u00f3n orientada a objetos). B\u00e1sicamente, cuando implementamos una interfaz, toda su implementaci\u00f3n se suma a la clase.   Ahora, pasamos la instancia al adaptador:  private void setAdapter() {\n    adapter = new DogListAdapter(this);\n}  Por \u00faltimo, abrimos la nueva actividad. Para ello debemos trabajar con los intents.", 
            "title": "Nota"
        }, 
        {
            "location": "/nueva_actividad/#que-es-un-intent", 
            "text": "Seg\u00fan la  documentaci\u00f3n de Android , un intent es  un objeto de acci\u00f3n que puedes usar para solicitar una acci\u00f3n de otro componente de la aplicaci\u00f3n  . Hay dos tipos de Intents:   Expl\u00edcitos: especifican que componente queremos abrir seg\u00fan su nombre (nombre de clase). Las usamos para abrir nuevas actividades de nuestra aplicaci\u00f3n.  Impl\u00edcitos: aqu\u00ed no se especifica qu\u00e9 componente vamos a abrir pero declara una acci\u00f3n general a realizar. Por ejemplo el abrir un mapa o el compartir algo por una red social.", 
            "title": "\u00bfQu\u00e9 es un intent?"
        }, 
        {
            "location": "/nueva_actividad/#declarando-nuestro-intent-para-abrir-otra-actividad", 
            "text": "Nos vamos a nuestra funci\u00f3n  onClickBreed()  y a\u00f1adimos el siguiente c\u00f3digo:  @Override\npublic void onClickBreed() {\n    Intent intent = new Intent(this, DogDetailsActivity.class);\n    startActivity(intent);\n}  Ahora si probamos la app podremos abrir la nueva actividad.", 
            "title": "Declarando nuestro intent para abrir otra actividad"
        }, 
        {
            "location": "/nueva_actividad/#extra", 
            "text": "Como curiosidad, si vamos a nuestro AndroidManifest.xml y a\u00f1adimos la siguiente propiedad a nuestra nueva actividad nos aparecer\u00e1 la flecha para ir hacia atr\u00e1s.  android:parentActivityName= .MainActivity", 
            "title": "Extra"
        }
    ]
}